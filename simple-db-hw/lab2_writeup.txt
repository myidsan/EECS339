
2.1 Filter & Join
- Predicate.java: Some basic getter/setter methods implemented by using Field's compare method to compare between operands.
- JoinPredicate.java: This file was also very simple and made use of Field's compare function
- Filter.java: fetchNext method is notable here. It iterates through the child iterator, applying the predicate filter function to7 do the selection.
- Join.java: fetchNext in Join is implemented as a nested whilte loop. It first loops on child1 and for each element loops on child2. It then forms a “comboTD” that would use the setField method to join the left and right tuple. Issue is that the nested while loop will make the database go slow.

2.2 Aggregates
- IntegerAggregator.java, StringAggregator.java: 
The IntegerAggregator was implemented using a HashMap (Private HashMap<String, AggregateFields>), mapping the group to values. Here, I created a helper struct with the name of AggregateFields that holds the aggregate command queries and dispatches them accordingly. 

The mergeTupleIntoGroup function would add the new tuple values into the map in constant time(thanks to HashMap), which keeps track of aggregate operations such as sum and count. For min and max, the values currently in the map are compared to check and look for the max, min value. AVG is sum divided by count.

The iterator is then implemented by iterating through the HashMap, creating the appropriate tuples, adding it to an ArrayList and returning the list's iterator. The StringAggregator was implemented in the same way, but only supports count. 

- Aggregate.java: Aggregate uses the Aggregators written above by grouping and doing the aggregate calculations for all the tuples in the child iterator. It's iterator then uses the Aggregator's iterator to get the results of a Group By query.

2.3 HeapFile Mutability
HeapPage.java: insertTuple does a linear search of the page through the header using isSlotUsed to find a free space and then inserts a tuple into that slot, updating the header accordingly. deleteTuple gets the recordId from the tuple to be deleted and removes it from the tuples array and updates the header as well. Additional API named getFreePage was added in HeapFile.java. [Private HeapPage getFreePage(TransactionId tid) => returns a non-used empty page for a tuple to be inserted.] This was used to fetch a empty page and to insert the tuple there.



HeapFile.java: insertTuple looks linearly through the file for a page with a free slot and if it does not find one, creates a new page, inserts the tuple into that page (with HeapPage's insertTuple) and appends it to the file. deleteTuple determines the pageId from the tuple to be deleted and uses HeapPage's deleteTuple function to delete the tuple.


BufferPool.java: insertTuple and deleteTuple make use of HeapFile.java's insert and deleteTuple methods.  They get a list of modified pages from the databaseFile and then mark them as dirty and update them by pushing them into the cache.

2.4 Insertion & Deletion
Insert.java, Delete.java: fetchNext is implemented by iterating through the child iterator and using the BufferPool insert/deleteTuple function. A counter variables named insertedCount/deletedCount are used to keep track of how many items were inserted/deleted deleted. Eventually, they are returned as a one element tuple.

2.5 Page Eviction
Page Eviction Policy: Iterates through the cache and evict the first page we are able to flush to disk.


Missing or Incomplete Elements:
Nothing missing or incomplete, but there maybe some inconsistent variables names. It became apparent later in the lab work that naming variables in a certain style such as t_cache is easier to identify in the code and differentiate with the parameters. I went back to fix them in a consistent style and got much as I can find, but they are not fully converted since some of them made more sense with their original variable names: this may look inconsistent.

Overall / Difficulties
I’ve spent about a week and a half on the lab. First few days were 1 ~3 hours a day and then it became 4 ~5 hours per day as the week progressed. It took less time than the lab1 since I had an understanding of the basic framework this time. Discussing with friends were helpful through the lab: although we had different approach and implementation it was good to bounce off ideas.
HeapPageIterator and HeapFileIterator had some issues with the new HeapFileWriteTest so there were some major adjustments. 
Overall reading error messages on ant testing guided the lab in the right direction.
